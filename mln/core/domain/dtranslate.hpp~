#ifndef MLN_CORE_DOMAINS_DTRANSLATE_HPP
# define MLN_CORE_DOMAINS_DTRANSLATE_HPP

//# include <mln/core/domain.hpp>

# include <boost/range/value_type.hpp>
# include <boost/range/adaptor/transformed.hpp>


namespace mln {

  namespace internal
  {
    template <typename Domain>
    struct translate_fun
    {
      typedef std::binder1st<std::plus<typename boost::range_value<Domain>::type> > type;
    };

    //template <typename Domain>
    //using translate_fun = std::binder1st<std::add<typename boost::range_value<Domain>::type>>;
  };


  template <typename Domain>
  struct translated_domain
  {
    typedef boost::transformed_range<typename internal::translate_fun<Domain>::type, const Domain > type;
  };

  //template <typename Domain>
  //using translated_domain = boost::transformed_range<Domain, typename internal::translate_fun<Domain>::type >;


  //
  template <typename Domain>
  inline
  typename translated_domain<Domain>::type
  dtranslate(const Domain& domain, typename boost::range_value<Domain>::type p)
  {
    typedef typename boost::range_value<Domain>::type P;
    return boost::adaptors::transform(domain, std::bind1st(std::plus<P> (), p));
  }


} // end of namespace mln

#endif //!MLN_CORE_DOMAINS_DTRANSLATE_HPP
