#ifndef MLN_CORE_SLIDING_IMAGE_HPP
# define MLN_CORE_SLIDING_IMAGE_HPP

# include <mln/core/image_base.hpp>

namespace mln {



  ///
  /// \brief A sliding image is an image reduced to a domain
  /// which is defined by a siteset surrounding a point
  /// Typical applications are:
  /// + Neigborhood image restriction implementation
  /// + Sliding Window image restriction implementation
  ///
  /// \tparam Image The image to be restricted
  /// \tparam SiteSet The set of points that defines the domain
  /// \pre Image must model a Forward Image

  template <typename Image, typename SiteSet, typename image_category = image_traits<Image>::category>
  struct sliding_image;


/******************************************/
/****          Implementation          ****/
/******************************************/


  namespace internal {

    template <typename Image, typename SiteSet, typename image_tag>
    struct sliding_image_base;

  } // end of namespace mln::internal

  template <typename Image, typename SiteSet>
  struct image_traits< sliding_image<Image, SiteSet> >
  {
    typedef forward_image_tag   category;
    static const bool accessible = false;
  };


  template <typename Image, unsigned N>
  struct sliding_image_base<Image, std::array<typename Image::point_type, N>, raw_image_tag>
      : image_base<typename Image::point_type, // point
                   typename Image::value_type, // value
                   typename std::conditional<std::is_const<Image>::value,
                                             typename Image::const_reference,
                                             typename Image::reference>::type, // reference
                   typename Image::const_reference,
                   typename std::conditional<std::is_const<Image>::value,
                                             typename Image::const_pointer,
                                             typename Image::pointer>::type, // pointer
                   typename Image::const_pointer> // const_pointer
  {
  private:
    static const bool isconst = std::is_const<Image>::value;

  public:
    enum {ndim = Image::ndim};

    typedef typename translated_domain<SiteSet>::type   domain_type;
    typedef typename std::conditional<isconst,
                                      typename Image::const_pixel_type,
                                      typename Image::pixel_type>::type pixel_type;


    typedef typename Image::size_type size_type;
    typedef typename Image::difference_type difference_type;

    typedef sliding_image_value_iterator<Image, SiteSet> value_iterator;
    typedef sliding_image_value_iterator<const Image, SiteSet> const_value_iterator;



    typedef boost::iterator_range<value_iterator> value_range;
    typedef boost::iterator_range<value_iterator> const_value_range;
    typedef /* fixme */ pixel_range;
    typedef /* fixme */ const_pixel_range;

    sliding_image(Image& ima, const SiteSet& dpoints) :
      :  dpoints_ (dpoints)
#ifndef MLN_NDEBUG
      ,ima_(&ima)
#endif
    {
      wrt_offset(ima, dpoints_, offsets_.begin());
    }


    domain_type domain() const
    {
      return dtranslate(s_, pix_.point());
    }


    value_range values()
    {
      return boost::iterator_range(value_iterator(&pix_.val(), offsets_, 0),
                                   value_iterator(&pix_.val(), offsets_, N));
    }

    const_value_range values() const
    {
      return boost::iterator_range(const_value_iterator(&pix_.val(), offsets_, 0),
                                   const_value_iterator(&pix_.val(), offsets_, N),
    }

    value_range pixels();
    const_value_range pixels() const;

    void center(pixel_type p)
    {
      mln_precondition(&p.image() == ima_);
      pix_ = p;
    }

  private:
    #ifndef MLN_NDEBUG
    Image* ima_;
    #endif

    const SiteSet& dpoints_;
    std::array<Image::difference_type, N> offsets_;
    pixel_type pix_;
  };





  // Fwd
  template <typename Image, typename SiteSet, typename image_tag>
  struct sliding_image_pixel_iterator;

  namespace internal {


    template <typename Image, int N>

    {
      typedef typename translated_domain<typename Image::domain_type>::type domain_type;

      enum {ndim = Image::ndim };




      // iterators

      // For this image only:
      void center(pixel_type x) { ptr_ = x; }


    private:
      Image&                ima_;
      std::array<difference_type, N> offsets_;

      const point_type      (&dpoints_)[N];

      pointer               ptr_;
    };

  } // end of namespace mln::internal

} // end of namespace mln

# include <mln/core/sliding_image_iterator.hpp>

#endif //!MLN_CORE_SLIDING_IMAGE_HPP
